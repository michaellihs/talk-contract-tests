== Pact: https://docs.pact.io/documentation/how_does_pact_work.html[Terminology]
Consumer::
    A component that initiates a HTTP request to another component (the service +Provider+).
Provider::
    A server that responds to an HTTP request from another component (the service +Consumer+).
Interaction::
    One invocation of the +Provider+ by the +Consumer+ including send arguments and expected response.
Contract::
    A file containing the JSON serialised +interactions+ (requests and responses) that were defined in the +Consumer+ tests. (aka the pact file)
//    A collection of agreements between a +Consumer+ and a +Provider+ that describes the +interactions+ that can take place between them.
//    A collection of interactions between +Consumer+ and a +Provider+.1


Pact::
    A testing tool that helps you write +Contracts+, and guarantees those +Contracts+ are satisfied.


[NOTE.speaker]
--
https://www.w3.org/2001/tag/doc/versioning[Extending and Versioning Languages: Terminology]
--
=== Pact: Goal of Contracts

Contracts should be about catching:

- bugs in the consumer
- misunderstanding from the consumer about end-points or payload
- breaking changes by the provider on end-points or payload

Pact scenarios should not dig into the business logic of the Provider.

[NOTE.speaker]
--
see https://docs.pact.io/best_practices/contract_tests_not_functional_tests.html for details
--

=== Pact: Example

"Given ... a request for ... will return ..."

[source]
----
Given an alligator with the name Mary exists *
Upon receiving a request to retrieve an alligator by name ** from Some Consumer
With {"method" : "get", "path" : "/alligators/Mary" }
Some Provider will respond with { "status" : 200, ...}

* This is the provider state
** This is the request description
----


[NOTE.speaker]
--
Pact is essentially a unit testing framework using specification by example.
--

=== Pact: Verification

would add a caution to make sure you are not affecting behavior with your mocks and stubs.
This is about running the service as is

=== Pact: How to keep the pact file in sync?
Instead of having to build a test environment running with two servers and databases to test that our interaction between our source system and our event API works, we now have two fast tests that achieve the same result. As long as we maintain the pact file between the two systems, we can be reasonably sure that our integration is working correctly.

There is a number of ways of maintaining the pact file. We can get our consumer build to publish the pact file to the CI server as a build artefact. The pact verification task supports loading the pact file from a URL. That way we can get it to always use the pact file from the latest successful build.

There is also a Pact Broker project that provides a repository of pact files. It allows you to be able to verify your providers against pact files from different versions of your consumer.

=== Pact: Provider State

=== Pact: Provider Side Changes break Client

* forget IgnoreUnknowns on Java DTO and add additional fields on the Provider.

=== Pact: Matchers

Request matching (when does the mock provider return the expected values)
* no unexpected values in the json body or query string
* unexpected headers are allowed

Response matching (during verification on the provider side)
* make sure the types are matching (Array, String, boolean, Fixnum, ...)
* unexpected values in JSON are ignored
* it is not possible to verify that something is not there.

[NOTE.speaker]
--
https://docs.pact.io/documentation/matching.html[matching]
https://docs.pact.io/documentation/gotchas.html[gotchas]
https://github.com/DiUS/pact-jvm/tree/master/pact-jvm-consumer-junit
https://github.com/DiUS/pact-jvm/wiki/Matching#matcher-path-expressions
--

=== Pact: Findings

- Matchers: 85 vs. 85.0
- Consumer passing arguments for state changes works only on pact-jvm?
- I do not like that I have to set the output directory for pact files via system property
- The pact-jvm project uses a mix of groovy, java, scala, kotlin code, bit daunting. Why is not clear to me.
- Documentation on jvm specific details is cluttered and all over the repository. Outdated links and code samples as well.
- Why do I need the dsl to define json?
- Pact files seem to be merge when being written to a file with what is already there.

[NOTE.speaker]
--
equals is used to compare numbers
matching more complex string cases seem to be fiddly.
maybe lack of knowledge/experience with the tool?
Limitation of the jvm implementation?
--

=== https://github.com/pact-foundation/pact_broker[Pact Broker]

- keep pacts in sync
- map the relationships between your services
- track compatibility across different versions



- https://pact.dius.com.au/[free hosted pact brokers]


verification results are published back to the broker
- What is it
- https://github.com/pact-foundation/pact_broker[pact-broker on github]
- https://github.com/pact-foundation/pact_broker/wiki/Overview
- https://github.com/pact-foundation/pact_broker/wiki/Using-tags
- https://github.com/pact-foundation/pact_broker/wiki/How-to-ensure-backwards-compatibility-by-tagging-pacts

[NOTE.speaker]
--
pact test should be unit tests
- https://github.com/DiUS/pact-jvm/issues/640#issuecomment-367525621[Source]
- https://docs.pact.io/documentation/usage_ruby.html[Source2]
--

=== Sources

https://dius.com.au/2014/05/19/simplifying-micro-service-testing-with-pacts/
http://rea.tech/enter-the-pact-matrix-or-how-to-decouple-the-release-cycles-of-your-microservices/
https://dius.com.au/2016/02/03/pact-101-getting-started-with-pact-and-consumer-driven-contract-testing/
https://dius.com.au/2018/01/21/closing-the-loop-with-pact-verifications/

https://docs.pact.io/documentation/what_is_pact_good_for.html[What is pact good for and not]

https://github.com/pact-foundation[pact foundation]
https://github.com/pact-foundation/pact-specification[pact specification]
https://docs.pact.io/documentation/implementation_guides.html[Workshops]
https://docs.pact.io/best_practices/[Best Practices]
https://docs.pact.io/faq/[FAQ]

https://github.com/Mikuu/Pact-JVM-Example[Pact-JVM-Example]

=== Pact: Supported languages

https://docs.pact.io/

=== Pact: Tools

https://github.com/pact-foundation/README

https://bitbucket.org/atlassian/swagger-mock-validator[swagger-mock-validator]

=== Pact: What changed between versions

v1

v2

Auf 3:
 provider state -> provider states
 message queues

CAUTION: If you are writing tests on the Consumer side to a different language on the Provider side, you must ensure you use a common Pact Specification between them or you will be unable to validate.

=== Pact: Where to use it
- If you control code for the consumer and the provider
- public apis are not suited, better of with Swagger documentation

=== Pact: What can not be ensured with this approach
- Firewall rules and network connectivity

=== Pact: What benefits do you see?
- You know your clients
- You get people from the consumer talking to the producer people
- Easier tracing which fields are use and by whom